### Kernel Mode
There is a kernel mode and use mode.
When we say kernel mode we usually refer to the OS itself.
The kernel mode is on the hardware level there is a bit that is on
saying that we are with kernel priviliges.
A system call comes from the usermode and access kernel mode via a specific operation and later return to user mod.
> Now depricated but once process id was kernel mode access now its in user space.
There are two typse of interrupts:
- Hardware - External i.e keyboard, mouse, 
- Software - Internal i.e exceptions and traps 
> Great example of trap is break point in CLion
--
## Rec 3
### Singnals
- Notification sent to/by process or by the kernel 
- Meant to indicate an occourence of an event or exception
> SIGKILL - Force terminate, SIGTERM - Request process to terminate gracefully
> SIGINT - Cntrl C interrupt via terminal command by user

Singals are not interrupts
- Interrupts are by the HW or Software and received and handled by OS
- Signals  are generated by OS and received and handled by processes
> Strace can be used to trace signals
Signals can be caught some can't for example kill and stop
> OS sets runtime environment of default signal handlers
- Sigaction - gets a int sig, struct sigaction* new_act, struct sigaction *old_act)
Sigaction is the way for us to change the sigaction for a given signal.
*Signal Mask* - A blocklist for a specific signal for which signals can't interrupt
action = signal handler + signal mask + flags
We can define a signal masker for when we do a critical process
We can do a masking of a signals for a **race condition** meaning two signals arrived at the same time.
*sigprocmask* - gets a macro, sigset set of signals to do the action on,  
> Can be used to mask or unmask signals
### Threads
How can we execute many tasks efficiently?
> What defines a process ?  
- Registers - PC,SP etc
- memory
- enviroment (files etc)
#### PCB
Process Control Block
Owns everything the process needs to run 
Also saves priority relvant data, and the user's access rights (For use by OS)
**State** - Each process is first new -> admit (waiting for scheduler) -> running -> ready(if interrupt)-> waiting( i.e IO) -> terminated
#### Context switch
The switching of two process
#### Threads
Every process can be divided into subprocess 
Each thread has it's own flow control 
But they share the stack and registers
Multitasking  with context switching gives overhead
#### Thread Implementation
##### User level
- the OS isn't aware we are doing multithread (In Ex2 you implement a library for this )
> Context switch is done on user level removing some overhead
> Scheduling depends on implementation
> If user level thread does an IO the whole user multithread will be blocked. (Cause its not OS lvl)
Another thing is if one of the thread crashes  the OS will kill all the threads
- We don't use multi threading on the hardware!
###### Implementation
Switch between threads:
- Stop running  current thread
- Save current state of thread
- Jump to another thread
Sigsetjump - saves current place in code , CPU state and signal mask (The masked singals)
> What does it return?
- option 1 - return 0 ( we add it as part of the code)
- option 2 - return the line to return to ( jump from singlongjump input)
Siglongjump - go to saved location and restores the state mask returns null
> Sigsetjmp(sigjmp_buf_env, int save) (bookmark )
- What is saved in env - PC, place in code, SP, Signal mask
- What else state proiority
- What isn't saved - global variables, dynamicly allocated ones, local vars
##### The switch


##### Kernel Level
The kernel knows of them
they are multithreaded in the OS Level
IO doesnt block all threads
The threads are multi threaded on Hardware lvl
Overhead is more signifcant
> Which is better?
Usually Probably Kernel Level Threads without IO 
We give each thread a quantum to run , ran by scheduler

